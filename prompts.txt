# PROMPTS - FEATURE VOTING SYSTEM PROJECT

## Prompt 1
I need to build a feature voting system. Before we code, read @voting-feature.md and @development-guideline.md. Break down the architecture layers - backend (Clean Architecture), frontend (Atomic Design), and mobile. I want to understand dependencies between layers before we start.

## Prompt 2
Starting with backend using Clean Architecture. Create domain layer with Feature entity that validates itself (title max 200 chars, description required). Also create Vote as value object with user_identifier to prevent duplicates at domain level. Add DuplicateVoteError exception. Keep it pure Python - no framework imports.

## Prompt 2.1
Quick question on Vote value object - should I store timestamp when vote was cast? Could be useful for analytics later, but not sure if that's domain logic or infrastructure concern. What's the clean architecture approach here?

## Prompt 3
Application layer - create use cases: CreateFeature, ListFeatures, GetFeature, UpvoteFeature. For UpvoteFeature, check if user already voted, then create vote and increment count. Define repository interfaces (IFeatureRepository, IVoteRepository) as abstract base classes. Use cases depend on interfaces (dependency inversion from SOLID). Create DTOs for input/output.

## Prompt 3.1
Wait, ListFeaturesUseCase needs sorting. Add SortBy enum (VOTES, CREATED_AT) and Order enum (ASC, DESC) as parameters. Update IFeatureRepository interface to support find_all(sort_by, order).

## Prompt 3.2
Should repository methods be async since we're using asyncpg? Or keep them sync in interface and let implementation handle async? I'm leaning towards async in interface to be explicit about I/O operations. Thoughts?

## Prompt 4
Before implementing infrastructure, let's write tests to prove Clean Architecture works. Setup pytest and create test_create_feature_use_case.py with a fake in-memory repository. Test: successful creation, title too long (should raise validation error), missing description (should raise error). Also test_upvote_feature_use_case.py: successful vote, duplicate vote prevention (should raise DuplicateVoteError). This proves use cases work in isolation before we touch database.

## Prompt 4.1
For the fake repository - should I use unittest.mock or create actual FakeFeatureRepository class with in-memory dict? I prefer fake implementation because it's more realistic and we can reuse it. What's your take?

## Prompt 5
Now infrastructure layer - SQLAlchemy models (FeatureModel, VoteModel) with UUIDs for IDs. Add unique constraint on (feature_id, user_identifier) in votes table. Implement concrete repositories that convert between SQLAlchemy models and domain entities (adapter pattern). Setup async database connection with asyncpg driver. Create get_db_session dependency for FastAPI.

## Prompt 5.1
Looking at SQLAlchemy models - the relationship setup looks good, but you used backref. Should we use back_populates instead? It's more explicit and recommended in SQLAlchemy 2.0. Also, add indexes on created_at and votes_count - we're sorting by these frequently.

## Prompt 6
Presentation layer - Pydantic schemas for request/response with examples for Swagger. Routes: POST /api/v1/features, GET /api/v1/features?sort_by=votes&order=desc, GET /api/v1/features/{id}, POST /api/v1/features/{id}/vote. Setup dependency injection for use cases. Configure CORS. Add /health endpoint.

## Prompt 6.1
Error handling is wrong - you're returning 500 for DuplicateVoteError. That's not a server error, it's a conflict. Update: DuplicateVoteError → 409 Conflict, FeatureNotFoundError → 404, Validation → 422, only 500 for unexpected errors. Add proper error response schemas.

## Prompt 7
Backend Dockerfile with Python 3.11 slim, multi-stage build. Install dependencies first (layer caching), then copy code. Run alembic upgrade head before uvicorn starts. Create requirements.txt with: fastapi, uvicorn, sqlalchemy[asyncio], asyncpg, alembic, pydantic-settings, pytest. Also .env.example with DATABASE_URL and CORS_ORIGINS.

## Prompt 8
Next.js 14 frontend with App Router (modern approach with better layouts). Initialize with TypeScript strict mode, Tailwind, shadcn/ui. Run shadcn init, install components: button, card, input, textarea, badge, toast (atoms). Folder structure: components/atoms, molecules, organisms, templates, and app/ for pages.

## Prompt 8.1
Quick check - with App Router, should I use client components for everything interactive, or can some be server components? Thinking FeatureList could be server component that fetches initial data, then client components for voting. Does that sound right architecturally?

## Prompt 9
Molecules - FeatureCard: Takes Feature prop, displays in Card with title, description (truncated 2 lines), author badge, vote count, VoteButton. VoteButton: Optimistic updates - increment immediately, rollback if API fails. Disable during loading. FeatureForm: react-hook-form + zod. Validation: title 5-200 chars, description 10-2000 chars, author 2-100 chars. Trim whitespace.

## Prompt 9.1
FeatureCard description truncation - use CSS line-clamp instead of JS substring. It's cleaner and handles different screen sizes better. Update to use `className="line-clamp-2"`. Also add subtle hover effect on card - scale-105 transform with transition for better interactivity.

## Prompt 10
Organisms - FeatureList: Fetches on mount, responsive grid (1 col mobile, 2 tablet, 3 desktop). Dropdown for sorting (Most Voted, Newest). Loading skeleton while fetching. Empty state with create button. Header: Nav bar with app name and "Create Feature" button opening dialog. Use radix-ui toast for notifications.

## Prompt 10.1
Testing create flow - when someone creates a feature, it doesn't show in list immediately unless they refresh. Should I refetch entire list after creation, or just add new feature to local state optimistically? What's better for UX vs code cleanliness?

## Prompt 11
API client in lib/api.ts using native fetch. Base URL from NEXT_PUBLIC_API_URL env. Typed functions: createFeature, listFeatures, getFeature, voteFeature returning Promise<T>. Error handling: distinguish network errors (can't reach server) vs 4xx (show detail message) vs 5xx (generic). FastAPI returns {detail: "message"} format.

## Prompt 11.1
Getting CORS errors. Backend needs to allow credentials and frontend origin. Update CORS config: allow_origins: ["http://localhost:3000"], allow_credentials: True, allow_methods/headers: ["*"].

## Prompt 12
Pages with App Router: app/page.tsx (Home with FeatureList and create dialog), app/features/[id]/page.tsx (fetch feature server-side, show full description), app/layout.tsx (Root layout with Header and Toaster). Use loading.tsx and error.tsx for states.

## Prompt 12.1
Detail page fetches server-side but vote button needs client interaction. Is the pattern to have server component wrapper that fetches data and passes to client component for interactivity? Want to make sure I'm using App Router correctly.

## Prompt 13
Frontend Dockerfile with Node 18 alpine. Multi-stage: Stage 1 install dependencies, Stage 2 build (next build), Stage 3 production (next start). Expose 3000. Pass NEXT_PUBLIC_API_URL as build arg.

## Prompt 14
For mobile, going native iOS with Swift/SwiftUI instead of React Native. Reasons: shows I can work beyond JS ecosystem, better performance, truly native iOS experience, demonstrates architecting across different paradigms. Using MVVM pattern. Structure: Models/, Services/, ViewModels/, Views/, Components/.

## Prompt 14.1
Let me think about this Swift decision. It adds complexity for evaluator (needs Mac/Xcode to test). But worth it to show I can work with different paradigms beyond JavaScript. Plus MVVM in Swift mirrors separation we did in backend. Going ahead with Swift.

## Prompt 15
Data models as structs conforming to Codable and Identifiable: Feature with id, title, description, authorName, votesCount, createdAt, updatedAt. CreateFeatureRequest, VoteRequest. Important: Use CodingKeys to map Swift camelCase to API's snake_case (author_name, votes_count, created_at, updated_at).

## Prompt 15.1
For date parsing - API returns ISO8601 strings. Should I use custom DateFormatter or rely on Codable's default? I've had issues with timezone parsing before. What's most reliable approach?

## Prompt 16
APIService as singleton using async/await. Methods: listFeatures(sortBy:), getFeature(id:), createFeature(request:), voteFeature(id:, userIdentifier:). Custom APIError enum: networkError, decodingError, serverError(Int, String), notFound. Base URL configurable - localhost for simulator, but document users need their computer's IP for physical devices.

## Prompt 16.1
Hitting localhost from simulator works but should handle backend down more gracefully. Add timeout to URLSession (10 seconds) and retry logic with exponential backoff for network errors. Show user-friendly messages in ViewModels.

## Prompt 17
UserDefaultsService singleton to generate and persist unique user identifier (UUID). Prevents duplicate votes. Generate on first launch, store in UserDefaults, retrieve for all vote requests.

## Prompt 18
Before implementing Views, let's write ViewModels with proper testing in mind. FeaturesViewModel marked as @MainActor with @Published properties for features array, isLoading, errorMessage, sortOption. Methods: loadFeatures(), sortFeatures(), refresh(). CreateFeatureViewModel: Form state, validation, submit with loading state. FeatureDetailViewModel: Single feature state, vote method with optimistic update. Make these testable by injecting APIService dependency.

## Prompt 18.1
Just realized - when user votes on detail screen and goes back to list, vote count there is stale unless they pull-to-refresh. Should I use NotificationCenter to notify FeaturesViewModel when vote happens? Or is there cleaner SwiftUI way to share state between ViewModels?

## Prompt 19
SwiftUI Views - FeaturesListView: NavigationView with List, pull-to-refresh, sort picker in toolbar, loading/error/empty states. FeatureDetailView: ScrollView with full description, larger vote button, formatted date. CreateFeatureView: Form in Sheet with TextField validations, submit button disabled while loading. Use @StateObject and @ObservedObject properly.

## Prompt 20
Reusable FeatureCardView component - VStack with title (bold, 2 lines max), description (gray, 2 lines), HStack with author badge and vote button. Tappable with NavigationLink. Match web design: rounded corners, shadow, padding.

## Prompt 20.1
Looking at FeatureCardView - NavigationLink wraps entire card including vote button. Won't that trigger navigation when someone tries to vote? Should we make vote button separate tap target that stops propagation?

## Prompt 21
App entry point FeatureVotingApp.swift with @main. Configure Info.plist: NSAppTransportSecurity with NSAllowsArbitraryLoads for localhost testing (add note that production should use HTTPS). Target iOS 16+ to use latest SwiftUI features.

## Prompt 22
docker-compose.yml with proper orchestration. Database: postgres:15-alpine with health check (pg_isready), volume for persistence. Backend: depends_on database with health check condition, port 8000. Frontend: depends_on backend, port 3000. Shared network. Health checks ensure proper startup order.

## Prompt 22.1
Backend trying to connect to DB before postgres ready, even with health check. Getting "connection refused" on startup. Add startup script that waits for postgres to accept connections, then runs migrations, then starts uvicorn. Use retry logic with time.sleep.

## Prompt 22.2
About health checks - will docker-compose wait for health check to pass before starting dependent services, or just wait for service to start? Want to make sure backend doesn't start until postgres actually accepting connections.

## Prompt 23
.env.example files for each service with all required variables documented. Add notes for iOS development: Simulator use http://localhost:8000, Physical device use http://YOUR_COMPUTER_IP:8000 (find with ifconfig).

## Prompt 24
Comprehensive .gitignore: Python (__pycache__, *.pyc, venv/, .pytest_cache/), Node (node_modules/, .next/, out/), iOS (DerivedData/, *.xcuserstate, *.xcworkspace but keep .xcodeproj), Env (.env, .env.local), DB (*.db, postgres_data/), IDE (.vscode/, .idea/, .DS_Store).

## Prompt 25
README.md with: Project overview and architecture diagram (ASCII fine), Tech stack for each platform (with justifications), Prerequisites, Quick start (docker-compose up then localhost:3000), API endpoints with curl examples, iOS setup (open Xcode, update base URL if testing on device), Troubleshooting common issues. Mention TDD approach - tests written before infrastructure implementation.

## Prompt 26
ARCHITECTURE.md explaining: Clean Architecture layers in backend with dependency flow, Why we separated domain from infrastructure, Atomic Design in frontend with component hierarchy, MVVM in iOS and how it mirrors backend separation, Data flow (User → View → ViewModel → Service → API → Backend), Key patterns (Dependency Injection, Repository, DTO, Adapter), Database schema with relationships, Security (user_identifier, CORS, input validation). Add section on TDD approach showing how tests validated design before database implementation.

## Prompt 26.1
Reading architecture doc - should add section on trade-offs. Clean Architecture adds complexity for small app like this, but demonstrates enterprise patterns. Add "When to Use" section explaining this pattern shines with multiple developers, changing requirements, long-term maintenance. For solo project or MVP, simpler structure might be better. Shows I'm not applying patterns blindly.

## Prompt 27
QUICKSTART.md for evaluators: 1) docker-compose up (wait 30s), 2) Visit localhost:3000, 3) Create feature and upvote, 4) Check API docs at localhost:8000/docs, 5) iOS: Open in Xcode, update URL in APIService if needed, run on simulator, 6) Run backend tests with `docker exec -it feature-voting-backend pytest` to see TDD tests passing. Include curl commands to test API directly. Common issues: ports in use, docker not running, iOS signing requirements.